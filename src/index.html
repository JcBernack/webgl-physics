<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Vicsek model</title>
    <style type="text/css">
        body {
            margin: 0;
            overflow: hidden;
            cursor: pointer;
        }
    </style>
</head>
<body>

<script src="lib/three.min.js"></script>
<script src="lib/GPUComputationRenderer.js"></script>
<script src="lib/OrbitControls.js"></script>
<script src="lib/stats.min.js"></script>
<script src="lib/dat.gui.min.js"></script>

<script type="x-shader/x-fragment" id="computeDirection">
#define PI 3.1415926535897932384626433832795

uniform float noiseStrength;
uniform float interactionRadius;
uniform float systemSize;
const float width = resolution.x;
const float height = resolution.y;

float rand(vec2 co){
    return fract(sin(dot(co.xy, vec2(12.9898,78.233))) * 43758.5453);
}

void main()	{
    // get current particle properties
    vec2 cCoords = gl_FragCoord.xy / resolution.xy;
    vec4 cPosition = texture2D(texturePosition, cCoords);
    vec4 cDirection = texture2D(textureDirection, cCoords);

    vec4 neighborDirection = vec4(0.0);
    for (float y = 0.0; y < height; y++) {
        for (float x = 0.0; x < width; x++) {
            // get neighbor particle properties
            vec2 pCoords = vec2(x + 0.5, y + 0.5) / resolution.xy;
            vec4 pPosition = texture2D(texturePosition, pCoords);
            vec4 pDirection = texture2D(textureDirection, pCoords);
            vec4 dPos = pPosition - cPosition;
            // periodic boundary conditions are disregarded here
            if (length(dPos) < interactionRadius) {
                neighborDirection += pDirection;
            }
        }
    }
    float angle = 2.0 * PI * rand(cPosition.xy);
    vec4 randDirection = vec4(cos(angle), sin(angle), 0, 0);
    gl_FragColor = normalize(neighborDirection) + noiseStrength * randDirection;
}
</script>

<script type="x-shader/x-fragment" id="computePosition">
uniform float velocity;
uniform float systemSize;
void main() {
    // get current particle properties
    vec2 cCoords = gl_FragCoord.xy / resolution.xy;
    float cId = cCoords.y * resolution.x + cCoords.x;
    vec4 cPosition = texture2D(texturePosition, cCoords);
    vec4 cDirection = texture2D(textureDirection, cCoords);
    // integrate position
    vec4 newPosition = cPosition + cDirection * velocity;
    // apply periodic boundary conditions
    gl_FragColor = mod(newPosition + systemSize, 2.0 * systemSize) - systemSize;
}
</script>

<script type="x-shader/x-vertex" id="renderVS">
uniform sampler2D texturePosition;
void main() {
    vec3 pos = texture2D(texturePosition, uv).xyz;
    vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
    gl_PointSize = - 1000.0 / mvPosition.z;
    gl_Position = projectionMatrix * mvPosition;
}
</script>

<script type="x-shader/x-fragment" id="renderFS">
void main() {
    float len = length(gl_PointCoord - vec2(0.5, 0.5));
    if (len > 0.5) discard;
    gl_FragColor = vec4(1.0);
}
</script>

<script>

    var N = 128;

    var stats;
    var camera, scene, renderer, controls;
    var gpuCompute;
    var positionVariable;
    var directionVariable;
    var particleUniforms;
    var parameters = {
        noiseStrength: 0.6,
        interactionRadius: 2,
        velocity: 0.2,
        systemSize: 50
    };

    function initialize() {
        // append container
        var container = document.createElement("div");
        document.body.appendChild(container);
        // append stats graph
        stats = new Stats();
        container.appendChild(stats.dom);
        // append renderer
        renderer = new THREE.WebGLRenderer();
        renderer.setPixelRatio(window.devicePixelRatio);
        container.appendChild(renderer.domElement);
        // create camera and orbit controls
        camera = new THREE.PerspectiveCamera(75, 1, 5, 15000);
        camera.position.z = 100;
        controls = new THREE.OrbitControls(camera, renderer.domElement);
        // create scene
        scene = new THREE.Scene();
        // handle resizing
        windowResize();
        window.addEventListener("resize", windowResize, false);
        // initialize
        initializeCompute();
        initializeParameterGUI();
        initializeGeometry();
        updateUniforms();
    }

    function getShader(id) {
        return document.getElementById(id).textContent;
    }

    function initializeCompute() {
        gpuCompute = new GPUComputationRenderer(N, N, renderer);
        var positionTexture = gpuCompute.createTexture();
        var directionTexture = gpuCompute.createTexture();
        fillTexture(positionTexture, 2, parameters.systemSize, false);
        fillTexture(directionTexture, 2, 1, true);
        positionVariable = gpuCompute.addVariable("texturePosition", getShader("computePosition"), positionTexture);
        directionVariable = gpuCompute.addVariable("textureDirection", getShader("computeDirection"), directionTexture);
        gpuCompute.setVariableDependencies(positionVariable, [positionVariable, directionVariable]);
        gpuCompute.setVariableDependencies(directionVariable, [positionVariable, directionVariable]);
        updateUniforms();
        var error = gpuCompute.init();
        if (error !== null) {
            console.error(error);
        }
    }

    function restartSimulation() {
        var positionTexture = gpuCompute.createTexture();
        var directionTexture = gpuCompute.createTexture();
        fillTexture(positionTexture, 2, parameters.systemSize, false);
        fillTexture(directionTexture, 2, 1, true);
        gpuCompute.renderTexture(positionTexture, positionVariable.renderTargets[0]);
        gpuCompute.renderTexture(positionTexture, positionVariable.renderTargets[1]);
        gpuCompute.renderTexture(directionTexture, directionVariable.renderTargets[0]);
        gpuCompute.renderTexture(directionTexture, directionVariable.renderTargets[1]);
    }

    function initializeGeometry() {
        var positions = new Float32Array(N*N*3);
        var i, j;
        for (i = 0; i < N*N*3; i++) {
            positions[i] = 0;
            positions[i++] = 0;
            positions[i++] = 0;
        }
        var uvs = new Float32Array(N*N*2);
        var p = 0;
        for (j = 0; j < N; j++) {
            for (i = 0; i < N; i++) {
                uvs[p++] = i / ( N - 1 );
                uvs[p++] = j / ( N - 1 );
            }
        }
        var geometry = new THREE.BufferGeometry();
        geometry.addAttribute("position", new THREE.BufferAttribute(positions, 3));
        geometry.addAttribute("uv", new THREE.BufferAttribute(uvs, 2));
        particleUniforms = {
            texturePosition: { value: null },
            textureDirection: { value: null }
        };
        var material = new THREE.ShaderMaterial({
            uniforms: particleUniforms,
            vertexShader: getShader("renderVS"),
            fragmentShader: getShader("renderFS")
        });
        material.extensions.drawBuffers = true;
        var particles = new THREE.Points(geometry, material);
        particles.matrixAutoUpdate = false;
        particles.updateMatrix();
        scene.add(particles);
    }

    function fillTexture(texture, dimension, range, normalize) {
        var data = texture.image.data;
        var rand = [0, 0, 0, 0];
        var i, j;
        for (i = 0; i < data.length; i += 4 ) {
            // generate random vector of given dimension
            for (j = 0; j < dimension; j++){
                rand[j] = (Math.random() * 2 - 1) * range;
            }
            // normalize vector to unit length
            if (normalize) {
                var len = 0;
                for (j = 0; j < dimension; j++) len += rand[j]*rand[j];
                len = Math.sqrt(len);
                for (j = 0; j < dimension; j++) rand[j] /= len;
            }
            // copy vector texture data
            for (j = 0; j < 4; j++) data[i+j] = rand[j];
        }
    }

    function windowResize() {
        renderer.setSize(window.innerWidth, window.innerHeight);
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
    }

    function setParameter(parameters, uniforms, name) {
        if (!uniforms[name]) uniforms[name] = {};
        uniforms[name].value = parameters[name];
    }

    function updateUniforms() {
        var positionUniforms = positionVariable.material.uniforms;
        setParameter(parameters, positionUniforms, "velocity");
        setParameter(parameters, positionUniforms, "systemSize");
        var directionUniforms = directionVariable.material.uniforms;
        setParameter(parameters, directionUniforms, "noiseStrength");
        setParameter(parameters, directionUniforms, "interactionRadius");
        setParameter(parameters, directionUniforms, "systemSize");
    }

    function initializeParameterGUI() {
        var gui = new dat.GUI();
        var simFolder = gui.addFolder("Simulation parameters");
        simFolder.add(parameters, "noiseStrength", 0, 10.0).onChange(updateUniforms);
        simFolder.add(parameters, "interactionRadius", 0.1, 10.0).onChange(updateUniforms);
        simFolder.add(parameters, "velocity", 0.01, 1.0).onChange(updateUniforms);
        simFolder.add(parameters, "systemSize", 10, 200).onChange(updateUniforms);
        var buttonRestart = {
            restartSimulation: function() {
                restartSimulation();
            }
        };
        simFolder.add(buttonRestart, "restartSimulation");
        simFolder.open();
    }

    function render() {
        gpuCompute.compute();
        particleUniforms.texturePosition.value = gpuCompute.getCurrentRenderTarget(positionVariable).texture;
        particleUniforms.textureDirection.value = gpuCompute.getCurrentRenderTarget(directionVariable).texture;
        renderer.render(scene, camera);
        stats.update();
        requestAnimationFrame(render);
    }

    initialize();
    render();

</script>
</body>
</html>
