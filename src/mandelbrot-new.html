<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Mandelbrot</title>
    <style type="text/css">
        body {
            margin: 0;
            overflow: hidden;
            color: white;
        }

        canvas {
            cursor: pointer;
        }
    </style>
</head>
<body>

<canvas id="canvas"></canvas>

<script src="lib/dat.gui.min.js"></script>

<script>

    /**
     * Mandelbrot renderer with arbitrary precision and interlaced parallel updates
     * arbitrary precision library:
     * parallelization using WebWorkers: http://www.w3schools.com/html/html5_webworkers.asp
     */
    function Mandelbrot() {

        this.canvas = null;
        this.center = {
//            re: -0.7397963083081783,
//            im: 0.28826751312182947,
            re:-0.7397549703504344,
            im: 0.2883886250742989
        };
//        this.zoom = 1.149237505160272e-14;
        this.zoom = 0.00038786765799159173;

        var ctx = null;
        var workers = [];
//        var renderStart = 0;

        this.initWorkers = function(count) {
            var i;
            for (i = 0; i < workers.length; i++) {
                workers[i].terminate();
            }
            for (i = 0; i < count; i++) {
                var worker = new Worker("mandelbrot-worker.js");
                worker.addEventListener("message", this.message);
                workers.push(worker);
            }
        };

        this.message = function(e) {
//            var elapsed = performance.now() - renderStart;
//            console.log("received after", elapsed, e);
            var d = e.data;
            var image = ctx.createImageData(d.width, d.height);
            var k = 0;
            for (var i = 0; i < d.result.length; i++) {
                var c = d.result[i] / d.iterations * 255;
                //TODO: add fancy color mapping
                image.data[k++] = c;
                image.data[k++] = c;
                image.data[k++] = c;
                image.data[k++] = 255;
            }
            ctx.putImageData(image, d.x, d.y);
        };

        this.render = function() {
            console.log("rendering");
//            renderStart = performance.now();
            var grid = 16;
            var aspect = this.canvas.width / this.canvas.height;
            var d = {
                width: Math.ceil(this.canvas.width / grid),
                height: Math.ceil(this.canvas.height / grid),
                re_range: this.zoom / grid,
                im_range: this.zoom / grid / aspect,
                iterations: 200
            };
            var re_start = this.center.re - this.zoom / 2;
            var im_start = -this.center.im - this.zoom / 2 / aspect;
            var i = 0;
            for (var y = 0; y < grid; y++) {
                for (var x = 0; x < grid; x++) {
                    // pixel rectangle in the image
                    d.x = d.width * x;
                    d.y = d.height * y;
                    // rectangle in the complex plane
                    d.re_start = re_start + d.re_range * x;
                    d.im_start = im_start + d.im_range * y;
                    ctx.beginPath();
                    ctx.rect(d.x, d.y, d.width, d.height);
                    ctx.stroke();
                    ctx.font = "22px sans-serif";
                    ctx.textAlign = "center";
                    ctx.textBaseline = "middle";
                    ctx.fillText(i, d.x + d.width/2, d.y + d.height/2);
                    //TODO: wait till a worker has finishes its previous block before posting a new one
                    //TODO: cancel previous render if invoked again
                    //TODO: maybe don't use blocks, but use an interlaced update scheme
                    workers[i++].postMessage(d);
                    if (i == workers.length) i = 0;
                }
            }
        };

        this.init = function(canvas, workerCount) {
            ctx = canvas.getContext("2d");
            this.canvas = canvas;
            this.initWorkers(workerCount);
        };
    }

    var canvas = document.getElementById("canvas");
    var ctx = canvas.getContext("2d");
    var mandel = new Mandelbrot();
    mandel.init(canvas, 8);

    function resize() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        mandel.render();
    }

    var dragging = false;
    function mouseDown(e) {
        if (e.buttons == 1) {
            dragging = true;
        }
    }

    function mouseUp() {
        if (dragging) {
            dragging = false;
            mandel.render();
        }
    }

    var lastMoveEvent = null;
    function mouseMove(e) {
        if (dragging && lastMoveEvent != null) {
            var dx = e.screenX - lastMoveEvent.screenX;
            var dy = e.screenY - lastMoveEvent.screenY;
            mandel.center.re -= dx / canvas.width * mandel.zoom;
            mandel.center.im += dy / canvas.width * mandel.zoom;
            ctx.drawImage(canvas, dx, dy);
        }
        lastMoveEvent = e;
    }

    function mouseWheel(e) {
        var factor = 0.5;
        if (e.wheelDelta > 0) mandel.zoom *= 1 - factor;
        if (e.wheelDelta < 0) mandel.zoom *= 1 + factor;
        mandel.render();
    }
    canvas.addEventListener("mousedown", mouseDown);
    canvas.addEventListener("mouseup", mouseUp);
    canvas.addEventListener("mousemove", mouseMove);
    canvas.addEventListener("wheel", mouseWheel);
    window.addEventListener("resize", resize);
    resize();

</script>

</body>
</html>
