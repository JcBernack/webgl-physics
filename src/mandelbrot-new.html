<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Mandelbrot</title>
    <style type="text/css">
        body {
            margin: 0;
            overflow: hidden;
            color: white;
        }

        canvas {
            cursor: pointer;
        }
    </style>
</head>
<body>

<canvas id="canvas"></canvas>

<script src="lib/dat.gui.min.js"></script>

<script>

    // source: http://stackoverflow.com/a/14010215/804614
    function Spiral(offset) {
        var shift = Math.floor((offset-1)/2);
        var x = 0;
        var y = 0;
        var leg = 0;
        var layer = 1;
        this.x = shift;
        this.y = shift;
        this.next = function () {
            switch (leg) {
                case 0: x++; if (x == layer) leg++; break;
                case 1: y++; if (y == layer) leg++; break;
                case 2: x--; if (x == -layer) leg++; break;
                case 3: y--; if (y == -layer) { leg = 0; layer++; } break;
            }
            this.x = x + shift;
            this.y = y + shift;
        };
    }

    /**
     * Mandelbrot renderer with arbitrary precision and interlaced parallel updates
     * arbitrary precision library:
     * parallelization using WebWorkers: http://www.w3schools.com/html/html5_webworkers.asp
     */
    function Mandelbrot() {

        this.canvas = null;
        this.center = {
//            re: -0.7397963083081783,
//            im: 0.28826751312182947,
            re:-0.7397549703504344,
            im: 0.2883886250742989
        };
//        this.zoom = 1.149237505160272e-14;
        this.zoom = 0.00038786765799159173;
        this.iterations = 200;

        var ctx = null;
        var workers = [];
//        var renderStart = 0;

        this.initWorkers = function(count) {
            var i;
            for (i = 0; i < workers.length; i++) {
                workers[i].terminate();
            }
            for (i = 0; i < count; i++) {
                var worker = new Worker("mandelbrot-worker.js");
                worker.addEventListener("message", this.message);
                workers.push(worker);
            }
        };

        this.message = function(e) {
//            var elapsed = performance.now() - renderStart;
//            console.log("received after", elapsed, e);
            var d = e.data;
            var image = ctx.createImageData(d.width, d.height);
            var k = 0;
            for (var i = 0; i < d.result.length; i++) {
                var c = d.result[i] / d.iterations * 255;
                //TODO: add fancy color mapping
                image.data[k++] = c;
                image.data[k++] = c;
                image.data[k++] = c;
                image.data[k++] = 255;
            }
            ctx.putImageData(image, d.x, d.y);
        };

        this.render = function() {
            console.log("rendering");
//            renderStart = performance.now();
            var grid = 16;
            var aspect = this.canvas.width / this.canvas.height;
            var d = {
                width: Math.ceil(this.canvas.width / grid),
                height: Math.ceil(this.canvas.height / grid),
                re_range: this.zoom / grid,
                im_range: this.zoom / grid / aspect,
                iterations: this.iterations
            };
            var re_start = this.center.re - this.zoom / 2;
            var im_start = -this.center.im - this.zoom / 2 / aspect;
            var i = 0;
            var s = new Spiral(grid);
            for (var block = 0; block < grid*grid; block++) {
                // pixel rectangle in the image
                d.x = d.width * s.x;
                d.y = d.height * s.y;
                // rectangle in the complex plane
                d.re_start = re_start + d.re_range * s.x;
                d.im_start = im_start + d.im_range * s.y;
                ctx.beginPath();
                ctx.rect(d.x, d.y, d.width, d.height);
                ctx.stroke();
                ctx.font = "22px sans-serif";
                ctx.textAlign = "center";
                ctx.textBaseline = "middle";
                ctx.fillText(i, d.x + d.width/2, d.y + d.height/2);
                //TODO: wait till a worker has finishes its previous block before posting a new one
                //TODO: cancel previous render if invoked again
                //TODO: maybe don't use blocks, but use an interlaced update scheme
                workers[i++].postMessage(d);
                if (i == workers.length) i = 0;
                // advance spiral to the next block
                s.next();
            }
        };

        this.init = function(canvas, workerCount) {
            ctx = canvas.getContext("2d");
            this.canvas = canvas;
            this.initWorkers(workerCount);
        };
    }

    var canvas = document.getElementById("canvas");
    var ctx = canvas.getContext("2d");
    var mandel = new Mandelbrot();
    mandel.init(canvas, 8);

    function resize() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        mandel.render();
    }

    var dragging = false;
    function mouseDown(e) {
        if (e.buttons == 1) {
            dragging = true;
        }
    }

    function mouseUp() {
        if (dragging) {
            dragging = false;
            mandel.render();
        }
    }

    var lastMoveEvent = null;
    function mouseMove(e) {
        if (dragging && lastMoveEvent != null) {
            var dx = e.screenX - lastMoveEvent.screenX;
            var dy = e.screenY - lastMoveEvent.screenY;
            mandel.center.re -= dx / canvas.width * mandel.zoom;
            mandel.center.im += dy / canvas.width * mandel.zoom;
            ctx.drawImage(canvas, dx, dy);
        }
        lastMoveEvent = e;
    }

    function mouseWheel(e) {
        var factor = 0.5;
        if (e.wheelDelta < 0) factor = 1/factor;
        var midX = canvas.width/2;
        var midY = canvas.height/2;
        var x = midX/factor;
        var y = midY/factor;
        // render preview of the new image
        ctx.drawImage(canvas, midX-x, midY-y, x*2, y*2);
        // properly rerender the image
        mandel.zoom *= factor;
        mandel.render();
    }
    canvas.addEventListener("mousedown", mouseDown);
    canvas.addEventListener("mouseup", mouseUp);
    canvas.addEventListener("mousemove", mouseMove);
    canvas.addEventListener("wheel", mouseWheel);
    window.addEventListener("resize", resize);
    resize();

</script>

</body>
</html>
