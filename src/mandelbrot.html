<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Mandelbrot</title>
    <style type="text/css">
        body {
            margin: 0;
            overflow: hidden;
            cursor: pointer;
            color: white;
        }
    </style>
</head>
<body>

<canvas id="canvas"></canvas>

<script src="lib/three.min.js"></script>
<script src="lib/stats.min.js"></script>
<script src="lib/dat.gui.min.js"></script>

<script type="x-shader/x-vertex" id="passthroughVS">
precision highp float;
attribute vec3 position;

void main() {
    gl_Position = vec4(position, 1.0);
}
</script>

<script type="x-shader/x-fragment" id="mandelbrotFS">
precision highp float;
//TODO: append max iterations as a #define from js to allow dynamically changing it
#define maxIterations 40.0
uniform vec2 window;
uniform float centerX;
uniform float centerY;
uniform float zoom;
uniform bool smoothColoring;
uniform bool antialiasing;

const float escape = 65536.0;
const float oneOverLog2 = 1.0 / log(2.0);

vec2 getScreenPos(vec2 fragCoord)
{
    return (fragCoord / window - 0.5) * vec2(1.0, window.y / window.x);
}

float mandelbrot(vec2 pos)
{
    vec2 c = pos / zoom + vec2(centerX, centerY);
    vec2 z = vec2(0.0);
    float escape2 = escape*escape;
    for (float i = 0.0; i < maxIterations; i++)
    {
        // z(n+1) = z(n)^2 + c
        float re = z.x*z.x - z.y*z.y;
        z.y = 2.0 * z.x * z.y;
        z.x = re;
        z += c;
        if (z.x*z.x + z.y*z.y > escape2)
        {
            if (!smoothColoring) return i;
            // source: https://en.wikipedia.org/wiki/Mandelbrot_set#Continuous_.28smooth.29_coloring
            float logZ = log(z.x*z.x + z.y*z.y) / 2.0;
            return i + 1.0 - log(logZ * oneOverLog2) * oneOverLog2;
        }
    }
    return maxIterations;
}

void main()
{
    float n = mandelbrot(getScreenPos(gl_FragCoord.xy));
    // anti-aliasing
    if (antialiasing)
    {
        vec2 a = vec2(0.0, 0.5);
        n += mandelbrot(getScreenPos(gl_FragCoord.xy + a.xy));
        n += mandelbrot(getScreenPos(gl_FragCoord.xy + a.yx));
        n += mandelbrot(getScreenPos(gl_FragCoord.xy + a.yy));
        n /= 4.0;
    }
    //TODO: add some fancy coloring
    gl_FragColor = vec4(n / maxIterations);
}
</script>

<script>

    var canvas, stats, gui;
    var renderer, scene, camera;
    var material, mesh;
    var parameters = {};
    var defaultParameters = {
        centerX: -0.5,
        centerY: 0,
        zoom: 0.33,
        targetZoom: 0.33,
        smoothColoring: true,
        antialiasing: true
    };

    function get(name) {
        return parameters[name];
    }

    function set(name, value) {
        parameters[name] = value;
        setUniform(name, value);
        requestRender();
        if (gui) {
            for (var i in gui.__controllers) {
                gui.__controllers[i].updateDisplay();
            }
        }
    }

    function reset() {
        for (var name in defaultParameters) {
            set(name, defaultParameters[name]);
        }
    }

    function setUniform(name, value) {
        var uniforms = material.uniforms;
        if (!uniforms[name]) uniforms[name] = {};
        uniforms[name].value = value;
    }

    function initialize() {
        // append stats graph
        stats = new Stats();
        document.body.appendChild(stats.dom);
        // initialize renderer
        canvas = document.getElementById("canvas");
        renderer = new THREE.WebGLRenderer({ canvas: canvas });
        // initialize
        initializeScene();
        reset();
        initializeParameterGUI();
        addEventHandlers();
        windowResize();
    }

    function getShader(id) {
        return document.getElementById(id).textContent;
    }

    function initializeScene() {
        // most arguments are meaningless here as the projection and modelview matrix are not used in the shader
        camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 1, 3);
        camera.position.z = 2;
        // create the mandelbrot materials
        material = new THREE.RawShaderMaterial({
            vertexShader: getShader("passthroughVS"),
            fragmentShader: getShader("mandelbrotFS"),
            depthTest: false,
            depthWrite: false
        });
        // create a plane mesh for each material
        var plane = new THREE.PlaneGeometry(2, 2);
        mesh = new THREE.Mesh(plane, material);
        scene = new THREE.Scene();
        scene.add(camera);
        scene.add(mesh);
    }

    function addParameter(name, step) {
        var c = gui.add(parameters, name);
        if (step) c.step(step);
        c.onChange(function () { set(name, parameters[name]) });
    }

    function initializeParameterGUI() {
        gui = new dat.GUI();
        addParameter("centerX", 1e-6);
        addParameter("centerY", 1e-6);
        addParameter("targetZoom");
        addParameter("smoothColoring");
        addParameter("antialiasing");
        gui.add({ reset: reset }, "reset");
    }

    function addEventHandlers() {
        canvas.addEventListener("mousemove", mouseMove);
        canvas.addEventListener("wheel", mouseWheel);
        window.addEventListener("resize", windowResize);
    }

    var lastMoveEvent = null;
    function mouseMove(e) {
        if (lastMoveEvent != null && e.buttons == 1) {
            var zoom = get("zoom");
            var centerX = get("centerX") - (e.screenX - lastMoveEvent.screenX) / canvas.width / zoom;
            var centerY = get("centerY") + (e.screenY - lastMoveEvent.screenY) / canvas.width / zoom;
            set("centerX", centerX);
            set("centerY", centerY);
        }
        lastMoveEvent = e;
    }

    function mouseWheel(e) {
        var factor = 0.1;
        var target = get("targetZoom");
        if (e.wheelDelta > 0) target *= 1 + factor;
        if (e.wheelDelta < 0) target *= 1 - factor;
        set("targetZoom", target);
    }

    function windowResize() {
        var w = window.innerWidth;
        var h = window.innerHeight;
        renderer.setSize(w, h);
        setUniform("window", new Float32Array([w,h]));
        setUniform("width", w);
        setUniform("height", h);
        requestRender();
    }

    var rendering = false;
    function requestRender() {
        if (rendering) return;
        rendering = true;
        requestAnimationFrame(render);
    }

    function render() {
        var targetZoom = get("targetZoom");
        var zoom = get("zoom");
        if (Math.abs(zoom - targetZoom) > 0.000001) {
            zoom += (targetZoom - zoom) * 0.5;
            set("zoom", zoom)
        } else {
            // stop render loop
            rendering = false;
        }
        renderer.render(scene, camera);
        stats.update();
        if (rendering) {
            requestAnimationFrame(render);
        }
    }

    initialize();
    render();

</script>
</body>
</html>
