<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Mandelbrot</title>
    <style type="text/css">
        body {
            margin: 0;
            overflow: hidden;
            cursor: pointer;
            color: white;
        }
    </style>
</head>
<body>

<canvas id="canvas"></canvas>

<script src="lib/three.min.js"></script>
<script src="lib/stats.min.js"></script>
<script src="lib/dat.gui.min.js"></script>

<script type="x-shader/x-vertex" id="renderVS">
void main() {
    gl_Position = vec4(position, 1.0);
}
</script>

<script type="x-shader/x-fragment" id="renderFS">
uniform vec2 centerX;
uniform vec2 centerY;
uniform float width;
uniform float height;
uniform float size;
uniform bool useDoubleEmulation;

const float maxIterations = 400.0;

// Emulation based on Fortran-90 double-single package. See http://crd.lbl.gov/~dhbailey/mpdist/
// Substract: res = ds_add(a, b) => res = a + b
vec2 ds_add (vec2 dsa, vec2 dsb)
{
    vec2 dsc;
    float t1, t2, e;

    t1 = dsa.x + dsb.x;
    e = t1 - dsa.x;
    t2 = ((dsb.x - e) + (dsa.x - (t1 - e))) + dsa.y + dsb.y;

    dsc.x = t1 + t2;
    dsc.y = t2 - (dsc.x - t1);
    return dsc;
}

// Substract: res = ds_sub(a, b) => res = a - b
vec2 ds_sub (vec2 dsa, vec2 dsb)
{
    vec2 dsc;
    float e, t1, t2;

    t1 = dsa.x - dsb.x;
    e = t1 - dsa.x;
    t2 = ((-dsb.x - e) + (dsa.x - (t1 - e))) + dsa.y - dsb.y;

    dsc.x = t1 + t2;
    dsc.y = t2 - (dsc.x - t1);
    return dsc;
}

// Compare: res = -1 if a < b
//              = 0 if a == b
//              = 1 if a > b
float ds_compare(vec2 dsa, vec2 dsb)
{
    if (dsa.x < dsb.x) return -1.;
    else if (dsa.x == dsb.x)
    {
        if (dsa.y < dsb.y) return -1.;
        else if (dsa.y == dsb.y) return 0.;
        else return 1.;
    }
    else return 1.;
}

// Multiply: res = ds_mul(a, b) => res = a * b
vec2 ds_mul (vec2 dsa, vec2 dsb)
{
    vec2 dsc;
    float c11, c21, c2, e, t1, t2;
    float a1, a2, b1, b2, cona, conb, split = 8193.;

    cona = dsa.x * split;
    conb = dsb.x * split;
    a1 = cona - (cona - dsa.x);
    b1 = conb - (conb - dsb.x);
    a2 = dsa.x - a1;
    b2 = dsb.x - b1;

    c11 = dsa.x * dsb.x;
    c21 = a2 * b2 + (a2 * b1 + (a1 * b2 + (a1 * b1 - c11)));

    c2 = dsa.x * dsb.y + dsa.y * dsb.x;

    t1 = c11 + c2;
    e = t1 - c11;
    t2 = dsa.y * dsb.y + ((c2 - e) + (c11 - (t1 - e))) + c21;

    dsc.x = t1 + t2;
    dsc.y = t2 - (dsc.x - t1);

    return dsc;
}

// create double-single number from float
vec2 ds_set(float a)
{
    vec2 z;
    z.x = a;
    z.y = 0.0;
    return z;
}

float emandel()
{
    vec2 e_tx = ds_set(gl_FragCoord.x);
    vec2 e_ty = ds_set(gl_FragCoord.y);

    // compute position in complex plane from current pixel
    vec2 zoom = ds_set(size);
    vec2 w = ds_set(width / 2.0 * size);
    vec2 h = ds_set(height / 2.0 * size);
    vec2 cx = ds_add(ds_add(centerX, ds_mul(e_tx, zoom)), w);
    vec2 cy = ds_add(ds_add(centerY, ds_mul(e_ty, zoom)), h);

    vec2 tmp;

    vec2 zx = cx;
    vec2 zy = cy;
    vec2 two = ds_set(2.0);

    float radius = 2.0;
    vec2 e_radius = ds_set(radius*radius);

    for(float n=0.0; n<maxIterations; n++)
    {
        tmp = zx;
        zx = ds_add(ds_sub(ds_mul(zx, zx), ds_mul(zy, zy)), cx);
        zy = ds_add(ds_mul(ds_mul(zy, tmp), two), cy);
        if( ds_compare(ds_add(ds_mul(zx, zx), ds_mul(zy, zy)), e_radius)>0.)
        {
            return(n + 1. - log(log(length(vec2(zx.x, zy.x))))/log(2.));	// http://linas.org/art-gallery/escape/escape.html
        }
    }
    return 0.;
}

void main()
{
    float n = emandel();

//    gl_FragColor = vec4(
//        (-cos(0.025*n)+1.0)/2.0,
//        (-cos(0.08*n)+1.0)/2.0,
//        (-cos(0.12*n)+1.0)/2.0,
//        1.0);

    gl_FragColor = vec4(n / maxIterations);
}

</script>

<script>

    var canvas, stats, gui;
    var camera, scene, renderer;
    var material;
    var guiParameters = {};

    var parameters = {
        centerX: { value: 0, isUniform: true, isDouble: true },
        centerY: { value: 0, isUniform: true, isDouble: true },
        size: { value: 3, isUniform: true },
        useDoubleEmulation: { value: 1, isUniform: true }
    };

    function get(name) {
        var value = window.localStorage.getItem(name);
        if (value == null) return parameters[name].value;
        return parseFloat(value);
    }

    function set(name, value) {
        window.localStorage.setItem(name, value);
        if (parameters[name].isDouble) {
            value = splitDouble(value);
            guiParameters[name+"_hi"] = value[0];
            guiParameters[name+"_lo"] = value[1];
        } else {
            guiParameters[name] = value;
        }
        if (parameters[name].isUniform) {
            setUniform(name, value);
        }
        requestRender();
        if (gui) {
            for (var i in gui.__controllers) {
                gui.__controllers[i].updateDisplay();
            }
        }
    }

    function initParameters() {
        for (var name in parameters) {
            set(name, get(name))
        }
        requestRender();
    }

    function reset() {
        window.localStorage.clear();
        initParameters();
    }

    function splitDouble(input) {
        var split = new Float32Array(2);
        split[0] = input;
        split[1] = input - split[0];
        return split;
    }

    function initialize() {
        // append stats graph
        stats = new Stats();
        document.body.appendChild(stats.dom);
        // initialize renderer
        canvas = document.getElementById("canvas");
        renderer = new THREE.WebGLRenderer({ canvas: canvas });
        // initialize
        initializeScene();
        initParameters();
        initializeParameterGUI();
        addEventHandlers();
        // handle resizing
        windowResize();
        window.addEventListener("resize", windowResize, false);
    }

    function addEventHandlers() {
        canvas.addEventListener("mousemove", mouseMove);
        canvas.addEventListener("wheel", mouseWheel);
    }

    var lastMoveEvent = null;
    function mouseMove(e) {
        if (lastMoveEvent != null && e.buttons == 1) {
            var size = get("size");
            var centerX = get("centerX");
            var centerY = get("centerY");
            centerX -= (e.screenX - lastMoveEvent.screenX) / canvas.width * size;
            centerY += (e.screenY - lastMoveEvent.screenY) / canvas.width * size;
            set("centerX", centerX, true);
            set("centerY", centerY, true);
        }
        lastMoveEvent = e;
    }

    function mouseWheel(e) {
        var factor = 0.1;
        var size = get("size");
        if (e.wheelDelta > 0) size *= 1 - factor;
        if (e.wheelDelta < 0) size *= 1 + factor;
        set("size", size, true);
    }

    function getShader(id) {
        return document.getElementById(id).textContent;
    }

    function initializeScene() {
        // most arguments are meaningless here as the projection and modelview matrix are not used in the shader
        camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 1, 3);
        camera.position.z = 2;
        // create the mandelbrot material
        material = new THREE.ShaderMaterial({
            vertexShader: getShader("renderVS"),
            fragmentShader: getShader("renderFS"),
            depthTest: false,
            depthWrite: false
        });
        scene = new THREE.Scene();
        scene.add(camera);
        scene.add(new THREE.Mesh(new THREE.PlaneGeometry(2, 2), material));
    }

    function windowResize() {
        var w = window.innerWidth;
        var h = window.innerHeight;
        renderer.setSize(w, h);
        setUniform("width", w);
        setUniform("height", h);
        requestRender();
    }

    function setUniform(name, value) {
        var uniforms = material.uniforms;
        if (!uniforms[name]) uniforms[name] = {};
        uniforms[name].value = value;
    }

    function initializeParameterGUI() {
        gui = new dat.GUI();
        gui.add(guiParameters, "centerX_hi").step(1e-6);
        gui.add(guiParameters, "centerX_lo").step(1e-6);
        gui.add(guiParameters, "centerY_hi").step(1e-6);
        gui.add(guiParameters, "centerY_lo").step(1e-6);
        gui.add(guiParameters, "size").step(1e-6);
        gui.add({ reset: reset }, "reset");
    }

    var rendering = false;
    function requestRender() {
        if (rendering) return;
        rendering = true;
        requestAnimationFrame(render);
    }

    function render() {
        rendering = false;
        renderer.render(scene, camera);
        stats.update();
    }

    initialize();
    render();

</script>
</body>
</html>
